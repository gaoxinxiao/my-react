[{"/Users/gaoxinxiao/Desktop/kkb-staduy/my-react/src/index.js":"1","/Users/gaoxinxiao/Desktop/kkb-staduy/my-react/src/greact-dom/index.js":"2"},{"size":2967,"mtime":1611119667087,"results":"3","hashOfConfig":"4"},{"size":8222,"mtime":1611124102827,"results":"5","hashOfConfig":"4"},{"filePath":"6","messages":"7","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1lygek8",{"filePath":"8","messages":"9","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"10"},"/Users/gaoxinxiao/Desktop/kkb-staduy/my-react/src/index.js",[],"/Users/gaoxinxiao/Desktop/kkb-staduy/my-react/src/greact-dom/index.js",["11"],"\nlet nextUnitOfWork = null // 下一个要执行的任务\n\nlet wipRoot = null\n/**\n * filber结构\n * stateNode dom结构\n * child 子节点\n * sibling 兄弟节点\n * return 父节点\n * alternate 记录老fiber 区分是更新操作还是初始化操作\n*/\n\n//work in progress正在工作的fiber\nlet wipFiber = null\n\n//记录上一次执行的节点\nlet currentRoot = null\n\nfunction render(vnode, container) {\n    //vnode -> node\n    // let node = createNode(vnode)\n    // container.appendChild(node)\n    wipRoot = {\n        type: \"div\",\n        props: { children: { ...vnode } },\n        stateNode: container,\n    };\n    nextUnitOfWork = wipRoot;\n}\n\n//更新属性\nfunction updateNode(node, prevProps, nextProps) {\n    Object.keys(prevProps)\n        // .filter(k => k !== \"children\")\n        .forEach(k => {\n            if (k === \"children\") {\n                // 有可能是文本\n                if (isStringOrNumber(prevProps[k])) {\n                    node.textContent = \"\";\n                }\n            } else if (k.slice(0, 2) === \"on\") {\n                const eventName = k.slice(2).toLocaleLowerCase();\n                node.removeEventListener(eventName, prevProps[k]);\n            } else {\n                if (!(k in prevProps)) {\n                    node[k] = \"\";\n                }\n            }\n        });\n    Object.keys(nextProps)\n        // .filter(k => k !== \"children\")\n        .forEach(k => {\n            if (k === \"children\") {\n                // 有可能是文本\n                if (isStringOrNumber(nextProps[k])) {\n                    node.textContent = nextProps[k] + \"\";\n                }\n            } else if (k.slice(0, 2) === \"on\") {\n                const eventName = k.slice(2).toLocaleLowerCase();\n                node.addEventListener(eventName, nextProps[k]);\n            } else {\n                node[k] = nextProps[k];\n            }\n        });\n}\n//生成dom结构 \nfunction createNode(workInProgress) {\n    const { type, props } = workInProgress;\n    let node = document.createElement(type);\n    updateNode(node, {}, props)\n    return node;\n}\n\nfunction updateHostComponent(workInProgress) {\n    if (!workInProgress.stateNode) {\n        // dom节点\n        workInProgress.stateNode = createNode(workInProgress);\n    }\n\n    // 协调子节点\n    // todo\n    reconcileChildren(workInProgress, workInProgress.props.children);\n}\n\n\nfunction reconcileChildren(workInProgress, children) {\n\n    if (isStringOrNumber(children)) {\n        return;\n    }\n\n    const newChildren = Array.isArray(children) ? children : [children];\n\n    let previousNewFiber = null;\n    //获取老节点的第一个子节点\n    let oldFiber = workInProgress.alternate && workInProgress.alternate.child\n    for (let i = 0; i < newChildren.length; i++) {\n        let child = newChildren[i];\n        let same = child && oldFiber &&\n            child.type === oldFiber.type &&\n            child.key === oldFiber.key\n\n        let newFiber\n        if (same) {\n            //都是同一个节点\n            //复用\n            newFiber = {\n                key: child.key || null, // 属性的标记节点\n                type: child.type,\n                stateNode: oldFiber.stateNode,\n                child: null,\n                sibling: null,\n                return: workInProgress,\n                alternate: oldFiber,\n                props: { ...child.props }, //属性\n                flags: 'Update'\n            };\n        }\n        if (!same && child) {\n            //新节点存在 新增\n            newFiber = {\n                key: child.key, // 属性的标记节点\n                type: child.type,\n                props: { ...child.props }, //属性\n                stateNode: null,\n                child: null,\n                sibling: null,\n                return: workInProgress,\n                flags: 'Placement'\n            };\n        }\n\n        if (!same && oldFiber) {\n            //老节点存在 删除\n        }\n\n        if (oldFiber) {\n            oldFiber = oldFiber.sibling\n        }\n\n        if (i === 0) {\n            //newFiber 是 workInProgress的第一个子fiber\n            workInProgress.child = newFiber;\n        } else {\n            previousNewFiber.sibling = newFiber;\n        }\n\n        previousNewFiber = newFiber;\n    }\n}\n\nfunction isStringOrNumber(sth) {\n    return typeof sth === \"string\" || typeof sth === \"number\";\n}\n\nfunction updateFunComp(workInProgress) {\n    //设置当前节点 和初始值\n    wipFiber = workInProgress\n    wipFiber.hooks = []\n    wipFiber.hookIndex = 0 //记录当前执行的useState \n\n    const { type } = workInProgress\n    let fun = type()\n    reconcileChildren(workInProgress, fun);\n}\n\n\nfunction updateFragmentComponent(workInProgress) {\n    reconcileChildren(workInProgress, workInProgress.props.children);\n}\n\n\nfunction updateClaComp(workInProgress) {\n    const { type } = workInProgress\n    let instance = new type()\n    let ele = instance.render()\n    reconcileChildren(workInProgress, ele);\n}\n\nfunction performUnitOfWork(workInProgress) {\n    //fiber结构执行方式\n    //1.step1 执行当前任务\n\n    let { type } = workInProgress\n\n    //创建原生标签节点\n    if (typeof type === 'string') {\n        updateHostComponent(workInProgress)\n    } else if (typeof type === 'function') {\n        type.prototype.isReactComponent\n            ? updateClaComp(workInProgress)\n            : updateFunComp(workInProgress);\n    } else {\n        updateFragmentComponent(workInProgress);\n    }\n\n    //2.step2 传递下一个要执行的任务\n    //2.1 如果子存在先把子返回\n    //2.2 子不存在 就判断兄弟  存在就返回\n    //2.3 以上都不存在就判断父级兄弟是否存在\n\n    if (workInProgress.child) {\n        return workInProgress.child\n    }\n\n    let nextFiber = workInProgress\n\n    while (nextFiber) {\n        if (nextFiber.sibling) {\n            return nextFiber.sibling\n        }\n        nextFiber = nextFiber.return\n    }\n\n}\n\nfunction woorkLoop(IdleDeadline) {\n    //有需要存在执行的任务 并且浏览器有空闲时间\n    while (nextUnitOfWork && IdleDeadline.timeRemaining() > 1) {\n        nextUnitOfWork = performUnitOfWork(nextUnitOfWork)\n    }\n    requestIdleCallback(woorkLoop)\n    //commin\n    if (!nextUnitOfWork && wipRoot) {\n        commitRoot()\n    }\n}\n\nfunction commitRoot() {\n    console.log(wipRoot, 'wipRoot')\n    commitWork(wipRoot.child)\n    currentRoot = wipRoot\n    wipRoot = null\n}\n\nfunction commitWork(workInProgress) {\n\n    if (!workInProgress) return\n\n    let parentFiber = workInProgress.return\n\n    while (!parentFiber.stateNode) {\n        parentFiber = parentFiber.return\n    }\n\n    let parentNode = parentFiber.stateNode\n\n    //存在dom节点才会进行插入\n    if (workInProgress.flags === 'Placement' && workInProgress.stateNode) {\n        parentNode.appendChild(workInProgress.stateNode)\n    } else if (workInProgress.flags === 'Update' && workInProgress.stateNode) {\n        //更新属性\n        updateNode(\n            workInProgress.stateNode,\n            workInProgress.alternate.props,\n            workInProgress.props,\n        )\n    }\n\n    commitWork(workInProgress.child)\n    commitWork(workInProgress.sibling)\n}\n\nrequestIdleCallback(woorkLoop)\n\nexport function useState(init) {\n\n    const oldHook = wipFiber.alternate && wipFiber.alternate.hooks[wipFiber.hookIndex]\n    //区分是初次渲染还是更新\n\n    //状态值修改状态的函数\n    const hooks = oldHook ? {\n        state: oldHook.state,\n        queue: oldHook.queue\n    } : {\n            state: init,\n            queue: []\n        }\n\n    const setState = (action) => {\n        hooks.queue.push(action)\n        //引起组件整体更新但是这里应该是从函数组件开始更新的 （目前的逻辑是从跟组件更新的）\n        wipRoot = {\n            alternate: currentRoot,\n            props: currentRoot.props,\n            stateNode: currentRoot.stateNode,\n        };\n        nextUnitOfWork = wipRoot\n    }\n\n\n    hooks.queue.forEach(action => {\n        //将新的 state赋值给 老的 state\n        hooks.state = action\n    })\n\n\n    wipFiber.hooks.push(hooks)\n    wipFiber.hookIndex++\n\n    return [hooks.state, setState]\n\n\n}\n\nexport default { render }\n\n",{"ruleId":"12","severity":1,"message":"13","line":307,"column":1,"nodeType":"14","endLine":307,"endColumn":26},"import/no-anonymous-default-export","Assign object to a variable before exporting as module default","ExportDefaultDeclaration"]